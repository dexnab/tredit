/*
 * contrast ratio related
 * 
 * note: Some code is originally generated by ChatGPT, but I made modifications.
 */
/* convert hsl to rgb */
function hslToRgb(h, s, l) {
	let r, g, b;

	if (s == 0) {
		/* achromatic */
		r = g = b = l;
	} else {
		function hue2rgb(p, q, t) {
			if (t < 0) t += 1;
			if (t > 1) t -= 1;
			if (t < 1 / 6) return p + (q - p) * 6 * t;
			if (t < 1 / 2) return q;
			if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
			return p;
		};

		let q = l < 0.5 ? l * (1 + s) : l + s - l * s;
		let p = 2 * l - q;
		r = hue2rgb(p, q, h + 1 / 3);
		g = hue2rgb(p, q, h);
		b = hue2rgb(p, q, h - 1 / 3);
	}

	return [r * 255, g * 255, b * 255];
}
/* convert rgb to relative luminance */
function luminance(r, g, b) {
	const a = [r, g, b].map(v => {
		v /= 255;
		return v <= 0.03928 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
	});
	return 0.2126 * a[0] + 0.7152 * a[1] + 0.0722 * a[2];
}
/* round to nearest integer multiple of `prec` */
function roundVal(x, prec) {
	return Math.round(x / prec) * prec;
}
/* bisection root finder */
function bisecRoot(x1, x2, x_prec, f, f_target, f_tol_p, f_tol_n) {
	/* boundary check */
	x1 = roundVal(x1, x_prec);
	x2 = roundVal(x2, x_prec);
	let f1 = f(x1);
	let f2 = f(x2);
	if (f1 <= f_target + f_tol_p && f_target - f_tol_n <= f1) {
		return {x: x1, err: false};
	}
	if (f2 <= f_target + f_tol_p && f_target - f_tol_n <= f2) {
		return {x: x2, err: false};
	}
	if (f_target < f1) {
		if (f_target < f2) {
			/* f_target > both */
			return {x: 0, err: true};
		}
	} else {
		if (f2 < f_target) {
			/* f_target < both */
			return {x: 0, err: true};
		}
	}
	/* bisection iteration */
	while (true) {
		let xc = roundVal((x1 + x2) / 2, x_prec);
		if (xc == x1 || xc == x2) {
			if (f_tol_p < f_tol_n) {
				/* return x giving smaller f */
				if (f1 < f2) {
					return {x: x1, err: false};
				} else {
					return {x: x2, err: false};
				}
			} else {
				/* return x giving larger f */
				if (f1 < f2) {
					return {x: x2, err: false};
				} else {
					return {x: x1, err: false};
				}
			}
		}
		let fc = f(xc);
		if (f_target - f_tol_n < fc && fc <= f_target + f_tol_p) {
			return {x: xc, err: false};
		}
		if (f_target < fc) {
			if (fc < f1) {
				x1 = xc;
			} else {
				/* fc < f2 */
				x2 = xc;
			}
		} else {
			if (f1 < fc) {
				x1 = xc;
			} else {
				/* f2 < fc */
				x2 = xc;
			}
		}
	}
}
/* evaluate contrast ratio */
function cr_hsl(h, s, l, lum_back) {
	let rgb = hslToRgb(h, s, l).map((x) => {
		return Math.round(x);
	});
	let lum = luminance(rgb[0], rgb[1], rgb[2]);
	return (Math.max(lum, lum_back) + 0.05) / (Math.min(lum, lum_back) + 0.05);
}
/* find lightness that achieves target contrast ratio */
function findLightness(h, s, lum_back, cr_target) {
	let result = bisecRoot(0, 1, 0.01, (l) => {
		return cr_hsl(h, s, l, lum_back);
	}, cr_target, 1e-5, 0);
	if (result.err) {
		/* No solution found within the bounds */
		return -1;
	}
	return result.x;
}

// Example usage:
console.log("Lightness of red in black background:", findLightness(0, 1, luminance(0, 0, 0), 7));
console.log("Lightness of red in white background:", findLightness(0, 1, luminance(255, 255, 255), 7));
console.log("Lightness of blue in black background:", findLightness(2/3, 1, luminance(0, 0, 0), 7));
console.log("Lightness of yellow in white background:", findLightness(1/6, 1, luminance(255, 255, 255), 7));